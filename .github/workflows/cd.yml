# .github/workflows/cd.yml
# 한국어: 지속적 배포 파이프라인
name: Continuous Deployment

on:
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push-images:
    name: Build and Push All Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        service:
          - name: backend
            dockerfile: Dockerfile.backend
            context: .
          - name: frontend
            dockerfile: Dockerfile
            context: ./frontend

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.service.name }}
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push ${{ matrix.service.name }} image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.context }}/${{ matrix.service.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.service.name }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.service.name }}:buildcache,mode=max

  deploy:
    name: Deploy to Server
    needs: build-and-push-images
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            echo "image_tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          else
            echo "image_tag=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          fi

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.0
        env:
          IMAGE_TAG: ${{ steps.vars.outputs.image_tag }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          REGISTRY: ${{ env.REGISTRY }}
          # Application Ports
          FRONTEND_PORT: ${{ vars.FRONTEND_PORT || '8080' }}
          BACKEND_PORT: ${{ vars.BACKEND_PORT || '5000' }}
          REDIS_PORT: ${{ vars.REDIS_PORT || '6379' }}
          # API Keys
          BROWSER_USE_API_KEY: ${{ secrets.BROWSER_USE_API_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          # SMTP Configuration
          SMTP_SERVER: ${{ vars.SMTP_SERVER || 'smtp.gmail.com' }}
          SMTP_PORT: ${{ vars.SMTP_PORT || '587' }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SENDER_EMAIL: ${{ secrets.SENDER_EMAIL }}
          SENDER_NAME: ${{ vars.SENDER_NAME || 'Issue Agent Bot' }}
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          envs: IMAGE_TAG,GITHUB_REPOSITORY,REGISTRY,FRONTEND_PORT,BACKEND_PORT,REDIS_PORT,BROWSER_USE_API_KEY,GOOGLE_API_KEY,SMTP_SERVER,SMTP_PORT,SMTP_USERNAME,SMTP_PASSWORD,SENDER_EMAIL,SENDER_NAME
          script: |
            # 배포 디렉토리로 이동
            cd ${{ secrets.DEPLOY_PATH || '/opt/issue-agent' }}

            # GitHub Container Registry 로그인
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            # 최신 코드 풀
            git pull origin main

            # Docker Compose로 서비스 재배포 (환경 변수는 SSH env에서 자동 전달됨)
            docker-compose -f docker-compose.prod.yml pull
            docker-compose -f docker-compose.prod.yml up -d --remove-orphans

            # 이전 이미지 정리
            docker image prune -af --filter "until=24h"

            # 서비스 상태 확인
            docker-compose -f docker-compose.prod.yml ps

      - name: Health check
        run: |
          sleep 30
          response=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.DEPLOY_HOST }}:5000/health || echo "000")
          if [ "$response" != "200" ]; then
            echo "Health check failed with status code: $response"
            exit 1
          fi
          echo "Deployment successful! Backend is healthy."

      - name: Notify deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ job.status }}';
            const message = status === 'success'
              ? '[+] Deployment completed successfully!'
              : '[-] Deployment failed!';

            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `${message}\n\nEnvironment: ${{ github.event.inputs.environment || 'production' }}\nImage Tag: ${{ steps.vars.outputs.image_tag }}`
            });
